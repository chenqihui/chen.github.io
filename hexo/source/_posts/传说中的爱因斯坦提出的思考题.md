---
title: 传说中的爱因斯坦提出的思考题
date: 2018-08-20 15:57:12
tags:
  - Swift
  - 数据结构
categories:
  - 算法
  
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近期看了 《[别乱说，算法才不是脑筋急转弯](https://mp.weixin.qq.com/s/aq7yEML5Kwt0vl-5uGTARw)》 这篇推文里面最后一题让人好奇（其实其他的也还不错，有些就是脑筋急转弯呀，真能用算法来写就强了），它就是是传说中的爱因斯坦提出的思考题，他宣称世界上只有2％的人能解出这个题目，你肯定听说过不下一次这道题，但也肯定你始终连题目都没记清楚过。因此也就试试解答下，居然断断续续合计花了两天，泪崩，并且还不是完美的答案。

<!-- more -->


#### 题目内容

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;据说有五个不同颜色的房间排成一排，每个房间里分别住着一个不同国籍的人，每个人都喝一种特定品牌的饮料，抽一种特定品牌的烟，养一种宠物，没有任意两个人抽相同品牌的香烟，或喝相同品牌的饮料，或养相同的宠物。
>
问题是谁在养鱼作为宠物？为了寻找答案，爱因斯坦给出了以下15条线索。
>
1. 英国人住在红色的房子里；
>
2. 瑞典人养狗作为宠物；
>
3. 丹麦人喝茶；
>
4. 绿房子紧挨着白房子，在白房子的左边；
>
5. 绿房子的主人喝咖啡；
>
6. 抽 Pall Mall 牌香烟的人养鸟；
>
7. 黄色房子里的人抽 Dunhill 牌香烟；
>
8. 住在中间那个房子里的人喝牛奶；
>
9. 挪威人住在第一个房子里面；
>
10. 抽 Blends 牌香烟的人和养猫的人相邻；
>
11. 养马的人和抽 Dunhill 牌香烟的人相邻；
>
12. 抽 BlueMaster 牌香烟的人喝啤酒；
>
13. 德国人抽 Prince 牌香烟；
>
14. 挪威人和住在蓝房子的人相邻；
>
15. 抽 Blends 牌香烟的人和喝矿泉水的人相邻。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以说乍一看才 15个条件 不算很多，可是很难记住，特别是 各个国家各个颜色等搭配，名字又难记。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到解题来看，第一想到的还是一个个来推演，条件还是有所联系，如 9. 挪威人住在第一个房子里面 和 14. 挪威人和住在蓝房子的人相邻 这两个明显就可以推断 第二个房子是蓝色、又如 4. 绿房子紧挨着白房子，在白房子的左边；、5. 绿房子的主人喝咖啡；和 8. 住在中间那个房子里的人喝牛奶，可以推断出绿房子只能是在 第四个房间，也就是第五个房子是白色，剩下 红色 和 黄色，再由 1. 英国人住在红色的房子里；就可以知道房子颜色的顺序为：黄-蓝-红-绿-白。想想这样推，理应可以一步步推演出来（除非条件不够，不过怎么可能呢），就是记不住得用下本子和笔......

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可是上面的推演是人工，如果给计算机就不可能这样推演，计算机如何来推演呢？一般想到的是穷举法，并给它筛选的条件，让计算机进行大量的比较运算来得出结果。最后写出的代码，没有去修正，也存在很多错误。

#### 条件代号

```
国籍：a（英国人、瑞典人、丹麦人、挪威人、德国人）161 - 165
房子：b（红色、绿色、白色、黄色、蓝色）177 - 181
烟：c（Pall Mall、Dunhill、Blends、BlueMaster、Prince）193 - 197
饮料：d（咖啡、牛奶、啤酒、茶、矿泉水）209 - 213
宠物：e（狗、鸟、猫、马、鱼）225 - 229
```


#### 代码输出情况

```
final00 = 3080000
final remove
final04 = 247520
final04 remove
final10 = 158690
final10 remove
final11 == 22645
final11 remove
final15 == 9133
final15 remove
ffinal1 == 7199
ffinal1 remove
ffinal2 == 6538
ffinal2 remove
ffinal3 == 2480
ffinal3 remove
ffinal4 == 2192
ffinal4 remove
ffinal5 == 1219
ffinal5 remove
ffinal12 == 246
fffinal01 remove
fffinal02 == 1765
fffinal02 remove
fffinal03 == 928
```
  

#### 答案

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后输出了 928 个，打印出来，会看到还有没填充满的，依然是 0，按照下面的步骤，应该继续填充，继续过滤。不过这里其实已经出答案了，在所以数据里面会发现一个已经填满的，并且出现多次。而它其实已经通过多层校验的，所以它很可能就是要找答案，如下
 
["a4", "b4", "c2", "d5", "e3"]
["a3", "b5", "c3", "d4", "e4"]
["a1", "b1", "c1", "d2", "e2"]
["a5", "b2", "c5", "d1", "e5"]
["a2", "b3", "c4", "d3", "e1"]
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对其进行人工检测，满足所有条件，也就是说它就是最后的答案：

***答案：德国人🇩🇪养鱼🐟***


#### 总结

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实找猫为条件筛选会更直接，可是这边我想排出房子排列的所有可能，并且这里的计算有重复，所以生成的数据其实很多都是重复的，还是没完成，只能说马马虎虎能看到答案。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这应该是最笨的计算方法了，而且还不通用，因为很多条件的过滤都是人工来编写，也就是不能直接给计算机条件，让它自己过滤，所以还比较笨。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机部分说到这里，后续有更好的写法也会更新。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后看看其他小伙伴的推演：《[题目是这样的： 已知条件：有5个具有5种不同颜色的房间；每个房间里分别住着一个不同国籍的人；每个人_百度知道](https://zhidao.baidu.com/question/1511701374647756780.html)》，大致跟最开始人工推演的类似，这里只是为了再次确认上面的答案是否真的正确。

![](https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=20f5626a9e45d688a357baa294f25126/91ef76c6a7efce1b7e1e6393a351f3deb48f65b6.jpg)


#### 附件代码

```swift
func start() {
    //1、将条件转换为各自可能
    let o1 = [0xa1, 0xb1, 0, 0, 0]
    let o2 = [0xa2, 0, 0, 0, 0xe1]
    let o3 = [0xa3, 0, 0, 0xd4, 0]
    let o4 = [0, 0xb2, 0, 0xd1, 0]
    let o5 = [0, 0, 0xc1, 0, 0xe2]
    let o6 = [0, 0xb4, 0xc2, 0, 0]
    let o7 = [0, 0, 0xc4, 0xd3, 0]
    let o8 = [0xa5, 0, 0xc5, 0, 0]
    
    let o9 = [0xa4, 0, 0, 0, 0]
    let o10 = [0, 0xb3, 0, 0, 0]
    let o11 = [0, 0xb5, 0, 0, 0]
    let o12 = [0, 0, 0xc3, 0, 0]
    let o13 = [0, 0, 0, 0xd2, 0]
    let o14 = [0, 0, 0, 0xd5, 0]
    let o15 = [0, 0, 0, 0, 0xe3]
    let o16 = [0, 0, 0, 0, 0xe4]
    let o17 = [0, 0, 0, 0, 0xe5]
    
    var os = [o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17]
    
    // 2、各自可能的组合
    var ons = [[Int]]()
    for index in 0..<os.count {
        let o = os[index]
        let subIndex = index + 1
        if subIndex < os.count {
            for idx in subIndex..<os.count {
                let ot = os[idx]
                var on = [0, 0, 0, 0, 0]
                var bMerge = true
                for i in 0..<5 {
                    if o[i] == 0 || ot[i] == 0 {
                        if o[i] != ot[i] {
                            on[i] = (o[i] + ot[i])
                        }
                    }
                    else {
                        bMerge = false
                        break
                    }
                }
                if bMerge == true {
                    ons.append(on)
                }
            }
        }
    }
    
    // 3、条件过滤，主要是 9、14、8
    // condition 9
    var ons9 = [[Int]]()
    for index in 0..<ons.count {
        let on = ons[index]
        if on[0] == 0xa4, on[1] != 0xb5, on[3] != 0xd2 {
            ons9.append(on)
        }
    }
    
    //var l = [[[Int]]]()
    var l: [Any] = [0, 0, 0, 0, 0]
    
    // 第一个位置的所有可能
    let l1 = ons9
    l[0] = l1
    
    var ons14 = [[Int]]()
    for index in 0..<ons.count {
        let on = ons[index]
        if on[1] == 0xb5, on[0] != 0xa4, on[3] != 0xd2 {
            ons14.append(on)
        }
    }
    
    let l2 = ons14
    l[1] = l2
    
    // condition 8
    var ons8 = [[Int]]()
    for index in 0..<ons.count {
        let on = ons[index]
        if on[3] == 0xd2, on[1] != 0xb5, on[0] != 0xa4 {
            ons8.append(on)
        }
    }
    
    let l3 = ons8
    l[2] = l3
    
    var l4 = ons
    for index in 0..<l1.count {
        let on = l1[index]
        l4.remove(at: l4.index(of: on)!)
    }
    for index in 0..<l2.count {
        let on = l2[index]
        l4.remove(at: l4.index(of: on)!)
    }
    for index in 0..<l3.count {
        let on = l3[index]
        l4.remove(at: l4.index(of: on)!)
    }
    
    var l5 = l4
    l[3] = l4
    l[4] = l5
    
    print("\(l1.count)")
    print("\(l2.count)")
    print("\(l3.count)")
    print("\(l4.count)")
    print("\(l5.count)")
    
    // 4、将简单的过滤掉之后，组合所有的5*5排列
    var final = [[[Int]]]()
    // l1.count
    for index1 in 0..<l1.count {
        let on1 = l1[index1]
        // l2.count
        for index2 in 0..<l2.count {
            let on2 = l2[index2]
            for index3 in 0..<l3.count {
                let on3 = l3[index3]
                for index4 in 0..<l4.count {
                    let on4 = l4[index4]
                    for index5 in 0..<l5.count {
                        let on5 = l5[index5]
                        if on4 != on5 {
                            let lf = [on1, on2, on3, on4, on5]
                            final.append(lf)
                        }
                    }
                }
            }
        }
    }
    
    print("final00 = \(final.count)")
    
    // 5、转换类似矩阵的计算再次过滤，主要是 4、10、11、15 这几个相邻条件
    
    // 4. 绿房子紧挨着白房子，在白房子的左边；b2 / b3
    var final4 = [[[Int]]]()
    for index in 0..<final.count {
        var lf = final[index]
        for i in 0..<4 {
            var bNext = false
            var lfo = lf[i]
            let ii = i + 1
            var lfor = lf[ii]
            if lfo[1] == 0xb2 {
                if lfor[1] == 0xb3 || lfor[1] == 0 {
                    bNext = true
                }
                else {
                    break
                }
            }
            else if lfo[1] == 0 {
                if lfor[1] == 0xb3 || lfor[1] == 0 {
                    bNext = true
                }
            }
            else if lfo[1] == 0xb3 {
                break
            }
            if bNext == true {
                for iii in (ii + 1)..<5 {
                    let lforr = lf[iii]
                    if lforr[1] == 0xb2 || lforr[1] == 0xb3 {
                        bNext = false
                        break
                    }
                }
            }
            if bNext == true {
                if lfo[1] == 0 {
                    if lfo[3] == 0xd1 {
                        lfo[1] = 0xb2
                    }
                    else if lfo[3] == 0, lfo[0] != 0xa3 {
                        lfo[1] = 0xb2
                    }
                    else {
                        break
                    }
                }
                if lfor[1] == 0 {
                    lfor[1] = 0xb3
                }
                lf[i] = lfo
                lf[ii] = lfor
                final4.append(lf)
                break
            }
        }
    }
    
    print("final remove")
    final.removeAll()
    print("final04 = \(final4.count)")
    
    // 10. 抽 Blends 牌香烟的人和养猫的人相邻；c3 / e3:195 / 227
    var final10 = [[[Int]]]()
    for index in 0..<final4.count {
        var lf = final4[index]
        for i in 0..<4 {
            var bNext = false
            var lfo = lf[i]
            let ii = i + 1
            var lfor = lf[ii]
            if lfo[2] == 0xc3 {
                if lfor[4] == 0xe3 {
                    bNext = true
                }
                else if lfor[4] == 0 {
                    lfor[4] = 0xe3
                    lf[ii] = lfor
                    bNext = true
                }
                else {
                    break;
                }
            }
            else if lfo[4] == 0xe3 {
                if lfor[2] == 0xc3 {
                    bNext = true
                }
                else if lfor[2] == 0 {
                    lfor[2] = 0xc3
                    lf[ii] = lfor
                    bNext = true
                }
                else {
                    break;
                }
            }
            else if lfo[2] == 0 {
                if lfor[4] == 0xe3 {
                    lfo[2] = 0xc3
                    lf[i] = lfo
                    bNext = true
                }
                else if lfor[4] == 0 {
                    bNext = true
                }
            }
            else if lfo[4] == 0 {
                if lfor[2] == 0xc3 {
                    lfo[4] = 0xe3
                    lf[i] = lfo
                    bNext = true
                }
                else if lfor[2] == 0 {
                    bNext = true
                }
            }
            if bNext == true {
                for iii in (ii + 1)..<5 {
                    let lforr = lf[iii]
                    if lforr[2] == 0xc3 || lforr[4] == 0xe3 {
                        bNext = false
                        break
                    }
                }
            }
            if bNext == true {
                var bInsert = true
                if lfo[2] == 0, lfor[4] == 0 {
                    lfo[2] = 0xc3
                    lf[i] = lfo
                    lfor[4] = 0xe3
                    lf[ii] = lfor
                    let lf1 = lf
                    final10.append(lf1)
                    bInsert = false
                }
                if lfo[4] == 0, lfor[2] == 0 {
                    lfo[4] = 0xe3
                    lf[i] = lfo
                    lfor[2] = 0xc3
                    lf[ii] = lfor
                    
                    let lf2 = lf
                    final10.append(lf2)
                    bInsert = false
                }
                if bInsert == true {
                    final10.append(lf)
                }
                break
            }
        }
    }
    
    print("final04 remove")
    final4.removeAll()
    print("final10 = \(final10.count)")
    
    // 11. 养马的人和抽 Dunhill 牌香烟的人相邻；e4 / c2:228 / 194
    var final11 = [[[Int]]]()
    for index in 0..<final10.count {
        var lf = final10[index]
        for i in 0..<4 {
            var bNext = false
            var lfo = lf[i]
            let ii = i + 1
            var lfor = lf[ii]
            if lfo[4] == 0xe4 {
                if lfor[2] == 0xc2 {
                    bNext = true
                }
                else if lfor[2] == 0, (lfor[1] == 0xb4 || lfor[1] == 0) {// TODO: 其他不能出现这个 后续条件
                    lfor[2] = 0xc2
                    lf[ii] = lfor
                    bNext = true
                }
                else {
                    break
                }
            }
            else if lfo[2] == 0xc2 {
                if lfor[4] == 0xe4 {
                    bNext = true
                }
                else if lfor[4] == 0 {
                    lfor[4] = 0xe4
                    lf[ii] = lfor
                    bNext = true
                }
                else {
                    break
                }
            }
            else if lfo[4] == 0 {
                if lfor[2] == 0xc2 {
                    lfo[4] = 0xe4
                    lf[i] = lfo
                    bNext = true
                }
                else if lfor[2] == 0 {
                    bNext = true
                }
            }
            else if lfo[2] == 0, (lfo[1] == 0xb4 || lfo[1] == 0) {
                if lfor[4] == 0xe4 {
                    lfo[2] = 0xc2
                    lf[i] = lfo
                    bNext = true
                }
                else if lfor[4] == 0 {
                    bNext = true
                }
            }
            if bNext == true {
                for iii in (ii + 1)..<5 {
                    let lforr = lf[iii]
                    if lforr[4] == 0xe4 || lforr[2] == 0xc2 {
                        bNext = false
                        break
                    }
                }
            }
            if bNext == true {
                var bInsert = true
                if lfo[2] == 0, lfor[4] == 0 {
                    if lfo[1] == 0xb4 || lfo[1] == 0 {
                        lfo[2] = 0xc2
                        lf[i] = lfo
                        lfor[4] = 0xe4
                        lf[ii] = lfor
                        let lf1 = lf
                        final10.append(lf1)
                    }
                    bInsert = false
                }
                if lfo[4] == 0, lfor[2] == 0 {
                    if lfor[1] == 0xb4 || lfor[1] == 0 {
                        lfo[4] = 0xe4
                        lf[i] = lfo
                        lfor[2] = 0xc2
                        lf[ii] = lfor
                        
                        let lf2 = lf
                        final10.append(lf2)
                    }
                    bInsert = false
                }
                if bInsert == true {
                    final11.append(lf)
                }
                break
            }
        }
    }
    
    print("final10 remove")
    final10.removeAll()
    print("final11 == \(final11.count)")
    
    // 15. 抽 Blends 牌香烟的人和喝矿泉水的人相邻。c3 / d5:195 / 213
    var final15 = [[[Int]]]()
    for index in 0..<final11.count {
        var lf = final11[index]
        for i in 0..<4 {
            var bNext = false
            var lfo = lf[i]
            let ii = i + 1
            var lfor = lf[ii]
            if lfo[2] == 0xc3 {
                if lfor[3] == 0xd5 {
                    bNext = true
                }
                else if lfor[3] == 0 {
                    lfor[3] = 0xd5
                    lf[ii] = lfor
                    bNext = true
                }
                else {
                    break
                }
            }
            else if lfo[3] == 0xd5 {
                if lfor[2] == 0xc3 {
                    bNext = true
                }
                else if lfor[2] == 0 {
                    lfor[2] = 0xc3
                    lf[ii] = lfor
                    bNext = true
                }
                else {
                    break
                }
            }
            else if lfo[2] == 0 {
                if lfor[3] == 0xd5 {
                    lfo[2] = 0xc3
                    lf[i] = lfo
                    bNext = true
                }
                else if lfor[3] == 0 {
                    bNext = true
                }
            }
            else if lfo[3] == 0 {
                if lfor[2] == 0xc3 {
                    lfo[3] = 0xd5
                    lf[i] = lfo
                    bNext = true
                }
                else if lfor[2] == 0 {
                    bNext = true
                }
            }
            if bNext == true {
                for iii in (ii + 1)..<5 {
                    let lforr = lf[iii]
                    if lforr[2] == 0xc3 || lforr[3] == 0xd5 {
                        bNext = false
                        break
                    }
                }
            }
            if bNext == true {
                var bInsert = true
                if lfo[2] == 0, lfor[3] == 0 {
                    lfo[2] = 0xc3
                    lf[i] = lfo
                    lfor[3] = 0xd5
                    lf[ii] = lfor
                    let lf1 = lf
                    final15.append(lf1)
                    bInsert = false
                }
                if lfo[3] == 0, lfor[2] == 0 {
                    lfo[3] = 0xd5
                    lf[i] = lfo
                    lfor[2] = 0xc3
                    lf[ii] = lfor
                    
                    let lf2 = lf
                    final15.append(lf2)
                    bInsert = false
                }
                if bInsert == true {
                    final15.append(lf)
                }
                break
            }
        }
    }
    
    print("final11 remove")
    final11.removeAll()
    print("final15 == \(final15.count)")
    
    // 6、去重，即将同组合，出现相同的配置去除，下面是针对 配置1、2、3、4、5逐一去重
    
    var ffinal1 = [[[Int]]]()
    for index in 0..<final15.count {
        var lf = final15[index]
        var bNext = true
        for j in 0..<4 {
            var lfo = lf[j]
            for i in (j+1)..<5 {
                var lfor = lf[i]
                if lfo[0] == 0 {
                    break
                }
                else if lfo[0] == lfor[0] {
                    bNext = false
                    break
                }
            }
            if bNext == false {
                break
            }
        }
        if bNext == true {
            ffinal1.append(lf)
        }
    }
    
    print("final15 remove")
    final15.removeAll()
    print("ffinal1 == \(ffinal1.count)")
    
    
    var ffinal2 = [[[Int]]]()
    for index in 0..<ffinal1.count {
        var lf = ffinal1[index]
        var bNext = true
        for j in 0..<4 {
            var lfo = lf[j]
            for i in (j+1)..<5 {
                var lfor = lf[i]
                if lfo[1] == 0 {
                    break
                }
                else if lfo[1] == lfor[1] {
                    bNext = false
                    break
                }
            }
            if bNext == false {
                break
            }
        }
        if bNext == true {
            ffinal2.append(lf)
        }
    }
    
    print("ffinal1 remove")
    ffinal1.removeAll()
    print("ffinal2 == \(ffinal2.count)")
    
    
    var ffinal3 = [[[Int]]]()
    for index in 0..<ffinal2.count {
        var lf = ffinal2[index]
        var bNext = true
        for j in 0..<4 {
            var lfo = lf[j]
            for i in (j+1)..<5 {
                var lfor = lf[i]
                if lfo[2] == 0 {
                    break
                }
                else if lfo[2] == lfor[2] {
                    bNext = false
                    break
                }
            }
            if bNext == false {
                break
            }
        }
        if bNext == true {
            ffinal3.append(lf)
        }
    }
    
    print("ffinal2 remove")
    ffinal2.removeAll()
    print("ffinal3 == \(ffinal3.count)")
    
    
    var ffinal4 = [[[Int]]]()
    for index in 0..<ffinal3.count {
        var lf = ffinal3[index]
        var bNext = true
        for j in 0..<4 {
            var lfo = lf[j]
            for i in (j+1)..<5 {
                var lfor = lf[i]
                if lfo[3] == 0 {
                    break
                }
                else if lfo[3] == lfor[3] {
                    bNext = false
                    break
                }
            }
            if bNext == false {
                break
            }
        }
        if bNext == true {
            ffinal4.append(lf)
        }
    }
    
    print("ffinal3 remove")
    ffinal3.removeAll()
    print("ffinal4 == \(ffinal4.count)")
    
    
    var ffinal5 = [[[Int]]]()
    for index in 0..<ffinal4.count {
        var lf = ffinal4[index]
        var bNext = true
        for j in 0..<4 {
            var lfo = lf[j]
            for i in (j+1)..<5 {
                var lfor = lf[i]
                if lfo[4] == 0 {
                    break
                }
                else if lfo[4] == lfor[4] {
                    bNext = false
                    break
                }
            }
            if bNext == false {
                break
            }
        }
        if bNext == true {
            ffinal5.append(lf)
        }
    }
    
    print("ffinal4 remove")
    ffinal4.removeAll()
    print("ffinal5 == \(ffinal5.count)")
    
    // 7、进行填充，类似数独，这次主要添加缺一配置的（即只有一个配置为 0 的进行填充）
    
    let cd1 = [0xa1, 0xa2, 0xa3, 0xa4, 0xa5]
    let cd2 = [0xb1, 0xb2, 0xb3, 0xb4, 0xb5]
    let cd3 = [0xc1, 0xc2, 0xc3, 0xc4, 0xc5]
    let cd4 = [0xd1, 0xd2, 0xd3, 0xd4, 0xd5]
    let cd5 = [0xe1, 0xe2, 0xe3, 0xe4, 0xe5]
    var cdc = [cd1, cd2, cd3, cd4, cd5]
    for idx in 0..<5 {
        for index in 0..<ffinal5.count {
            var lf = ffinal5[index]
            var cd = cdc[idx]
            var i0 = -1
            for i in 0..<5 {
                let lfo = lf[i]
                if lfo[idx] != 0 {
                    if let id = cd.index(of: lfo[idx]) {
                        cd.remove(at: id)
                    }
                }
                else {
                    i0 = i
                }
                if i == 4 {
                    if cd.count == 1, i0 > -1 {
                        var lfo = lf[i0]
                        lfo[idx] = cd[0]
                        lf[i0] = lfo
                    }
                }
            }
            ffinal5[index] = lf
        }
    }
    
    // 8、再次条件匹配，这些条件是前面提到的条件，列出的前8个，它们各自都有两个配置需要对应，这主要是去掉上面填写之后不符合的
    
    var fffinal01 = [[[Int]]]()
    var cdo = [o1, o2, o3, o4, o5, o6, o7, o8]
    
    for index in 0..<ffinal5.count {
        var lf = ffinal5[index]
        var bInsert = true
        for idx in 0..<cdo.count {
            let cdoo = cdo[idx]
            var ci1 = -1
            var ci2 = -1
            for ci in 0..<5 {
                if cdoo[ci] != 0 {
                    if ci1 != -1 {
                        ci2 = ci
                    }
                    else {
                        ci1 = ci
                    }
                }
            }
            for i in 0..<5 {
                let lfo = lf[i]
                if lfo[ci1] == cdoo[ci1] {
                    if lfo[ci2] == cdoo[ci2] || lfo[ci2] == 0 {
//                            fffinal01.append(lf)
//                            break
                    }
                    else {
                        bInsert = false
                        break
                    }
                }
                else if lfo[ci2] == cdoo[ci2] {
                    if lfo[ci1] == cdoo[ci1] || lfo[ci1] == 0 {
//                            fffinal01.append(lf)
//                            break
                    }
                    else {
                        bInsert = false
                        break
                    }
                }
                else {
//                        if i == 4 {
//                            fffinal01.append(lf)
//                        }
                }
            }
            if bInsert == false {
                break
            }
        }
        if bInsert == true {
            fffinal01.append(lf)
        }
    }
    
    print("ffinal5 remove")
    ffinal5.removeAll()
    print("ffinal12 == \(fffinal01.count)")
    
    // 9、填写 缺两个配置的
    
    var fffinal02 = [[[Int]]]()
    cdc = [cd1, cd2, cd3, cd4, cd5]
    for idx in 0..<5 {
        for index in 0..<fffinal01.count {
            var lf = fffinal01[index]
            var i0 = -1
            var i1 = -1
            var bInsert = false
            var cd = cdc[idx]
            for i in 0..<5 {
                let lfo = lf[i]
                if lfo[idx] != 0 {
                    if let id = cd.index(of: lfo[idx]) {
                        cd.remove(at: id)
                    }
                }
                else {
                    if i0 != -1 {
                        i1 = i
                    }
                    else {
                        i0 = i
                    }
                }
                if i == 4 {
                    if cd.count == 2 {
                        bInsert = true
                        for ii in 0..<2 {
                            let insert0 = cd[0]
                            let insert1 = cd[1]
                            
                            if ii == 0 {
                                var lfo0 = lf[i0]
                                lfo0[idx] = insert0
                                
                                var lfo1 = lf[i1]
                                lfo1[idx] = insert1
                                
                                lf[i0] = lfo0
                                lf[i1] = lfo1
                                let llf = lf
                                
                                fffinal02.append(llf)
                            }
                            else {
                                var lfo0 = lf[i0]
                                lfo0[idx] = insert1
                                
                                var lfo1 = lf[i1]
                                lfo1[idx] = insert0
                                
                                lf[i0] = lfo0
                                lf[i1] = lfo1
                                let llf = lf
                                
                                fffinal02.append(llf)
                            }
                        }
                    }
                }
            }
            if bInsert == false {
                fffinal02.append(lf)
            }
        }
    }
    
    print("fffinal01 remove")
    fffinal01.removeAll()
    print("fffinal02 == \(fffinal02.count)")
    
    // 10、再次去重
    
    var fffinal03 = [[[Int]]]()
    cdo = [o1, o2, o3, o4, o5, o6, o7, o8]
    
    for index in 0..<fffinal02.count {
        var lf = fffinal02[index]
        var bInsert = true
        for idx in 0..<cdo.count {
            let cdoo = cdo[idx]
            var ci1 = -1
            var ci2 = -1
            for ci in 0..<5 {
                if cdoo[ci] != 0 {
                    if ci1 != -1 {
                        ci2 = ci
                    }
                    else {
                        ci1 = ci
                    }
                }
            }
            for i in 0..<5 {
                let lfo = lf[i]
                if lfo[ci1] == cdoo[ci1] {
                    if lfo[ci2] == cdoo[ci2] || lfo[ci2] == 0 {
                    }
                    else {
                        bInsert = false
                        break
                    }
                }
                else if lfo[ci2] == cdoo[ci2] {
                    if lfo[ci1] == cdoo[ci1] || lfo[ci1] == 0 {
                    }
                    else {
                        bInsert = false
                        break
                    }
                }
                else {
                }
            }
            if bInsert == false {
                break
            }
        }
        if bInsert == true {
            fffinal03.append(lf)
        }
    }
    
    print("fffinal02 remove")
    fffinal02.removeAll()
    print("fffinal03 == \(fffinal03.count)")
    
    // 11、打印结果：结果还有 九百多个
    
    print("start")

    for index in 0..<fffinal03.count {
        let lf = fffinal03[index]
        for i in 0..<5 {
            let lfo = lf[i]
            var llf = [String]()
            for j in 0..<5 {
                let vv = String(lfo[j], radix: 16)
                llf.append(vv)
            }
            print("\(llf)")
        }
        print("--------------------------------------------------------------------------")
    }
    
    print("end")
    
    /*
     12、
     按理到这里还有没填充满的 0
     但是，当将输出到这里的数据打印出来，发现一个已经填满，并且出现多次
     因为已经填满的是通过多层校验，如下
     
     ["a4", "b4", "c2", "d5", "e3"]
     ["a3", "b5", "c3", "d4", "e4"]
     ["a1", "b1", "c1", "d2", "e2"]
     ["a5", "b2", "c5", "d1", "e5"]
     ["a2", "b3", "c4", "d3", "e1"]
     
     对其进行人工检测，所有条件匹配，也就是说它就是最后的答案
     答案：德国人🇩🇪养鱼🐟
     */
    
    /*
     其实找猫为条件筛选会更直接，可是这边我想排出房子排列的所有可能，
     并且这里的计算有重复，所以生成的数据其实很多都是重复的，还是没完成，只能说只是能看到答案
    */
}
```

